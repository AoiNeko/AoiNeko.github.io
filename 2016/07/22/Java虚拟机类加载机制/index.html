<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="langley, liangli171@gmail.com"><title>Java虚拟机类加载机制 · AoiNeko</title><meta name="description" content="类加载即虚拟机把class文件中描述类的数据加载到内存，校验，准备，解析，初始化，形成虚拟机可以使用的Java类型在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。对于引用数据类型reference来说，如数组引用、对象  加载  1.虚拟机通过类的全名来获取类"><meta name="keywords" content="Hexo,Java"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><e class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/mylogo.jpg" style="width:127px;"><h3 title=""><a href="/">AoiNeko</a></h3><div class="description"><p>一些个记录</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"></a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Hexo&#65281;</a></div></div></e><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Java虚拟机类加载机制</a></h3></div><div class="post-content"><p>类加载即虚拟机把class文件中描述类的数据加载到内存，校验，准备，解析，初始化，形成虚拟机可以使用的Java类型<br>在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。<br>对于引用数据类型reference来说，如数组引用、对象<br>  <strong>加载</strong><br>  1.虚拟机通过类的全名来获取类的二进制字节流.<br>  2.将字节流的静态存储结构转化为方法区的运行时数据结构.<br>  3.在堆中生成一个java.lang.Class的实例对象，作为方法区的入口(Class.forName(xx.xx.myClass)).</p>
<p>  类加载器分为<br>  1.启动类加载器，HotSpot中是由C++实现，无法被java程序直接引用.<br>  2.实现java.lang.ClassLoader接口的由java实现的其他类加载器.</p>
<p>  <strong><em>加载器加载class的双亲委派模型(parent delegate model)</em></strong><br>  <img src="https://i.stack.imgur.com/wduY1.png" alt="ClassLoaders" title="加载器示意"></p>
<p>  <strong>校验</strong><br>  确保class的字节流包含的信息符合虚拟机的要求。<br>  1.文件格式的验证：验证字节流是否符合Class文件格式的规范，保证输入的字节流可以正确解析并存储到方法区。<br>  2.元数据验证：语义校验（校验java的语法）例如类是否有父类，是否继承了不允许被继承的类，是否实现了接口方法…<br>  3.字节码验证：通过数据流和控制流分析，确定程序语义是合法的符合逻辑的<br>  4.符号引用验证：发生在符号引用转化为直接引用的时候–在解析阶段发生。验证内容：全限定名能否找到指定类，是否存在字段和方法，类、字段访问性</p>
<p>  <strong>准备</strong><br>  给类变量分配内存(static 变量),在这一阶段基本类型都被赋0值，但是如果是final static则会在准备阶段就赋值到ConstantValue中</p>
<p>  <strong>解析</strong><br>  将常量池内的符号引用转化为直接引用的过程。在Class文件中以Constant_Classinfo、Constant_Fieldref_info、Constant_Methodref_info等类型的常量出现。</p>
<p>  1.类、接口解析：解析一个出现的符号引用为对应的类时，可能触发其他相关的类的加载（如父类、实现的接口）。被解析类是数组类型时，符号引用是“[Ljava/lang/Integer]”类似的形式，此时会先解析数组的元素类。最后判断访问权限</p>
<p>  2.字段(Field)解析：解析字段 先会对该字段对应的类或接口的符号引用进行解析。如果类有同名字段则返回字段的引用，没有则按继承关系从下往上搜索接口和父接口，再没找到就同样搜索其父类。同样最后需要判断访问权限</p>
<p>  3.类方法解析：开始和字段解析一样，解析所属的类或接口，如果发现是接口方法则抛出IncompatibleClassChangeError，然后从本类开始递归往上查找简单名称和描述符都匹配的方法。 未找到则在类的实现接口中查找，如果存在说明这个类方法所属的类是个抽象类抛出AbstractMethodError，不存在则抛出NoSuchMethodError异常。 如未出现异常最后判断访问权限。</p>
<p>  4.接口方法解析：类似类方法解析，如果发现所属是类则抛出incompatibleClassChangeError。然后递归查找接口方法。未找则抛出异常。</p>
<p>  <strong>初始化</strong><br>  执行类的<code>&lt;clinit&gt;()</code>方法。 即执行类中的static修饰的代码。编译器会按顺序收集所有类变量的赋值动作和static语句块。JVM会保证父类的<code>&lt;clinit&gt;()</code>在子类的<code>clinit</code>之前执行。接口则会在引用到父接口时才调用其<code>&lt;clinit&gt;()</code></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-07-22</span><i class="fa fa-tag"></i><a href="/tags/Java/" title="Java" class="tag">Java </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2016/07/22/Java虚拟机类加载机制/,AoiNeko,Java虚拟机类加载机制,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/07/24/Java集合类/" title="Java集合类" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2016/07/19/markdown语法记录/" title="markdown语法记录" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>